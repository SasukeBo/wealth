# 7.2 垃圾收集器

编程语言的内存管理系统除了负责堆内存的分配外，还需要负责回收不再需要的对象和内存空间，这部分职责由垃圾收集器完成。

## 7.2.1 设计原理

当前的众多编程语言通常会采用手动和自动两种方式管理内存，
C/C++、Rust 等语言使用手动的方式管理内存，工程师需要在代码中显式的申请和释放内存，
而 Java、Ruby、Python 和 Go 等语言使用自动的内存管理系统，一般都是垃圾收集机制。
Object-C 使用了自动引用技术的方式来管理内存。

早期的垃圾收集器是 STW(stop the world)。

用户程序（Mutator）会通过内存分配器（Allocator）在堆上申请内存，而垃圾收集器（Collector）负责回收堆上的内存空间，
分配器和垃圾收集器共同管理程序中的堆内存空间。

### 标记清除

标记清除收集器是跟踪式垃圾收集器，其执行过程分为标记和清除两个阶段。

- 标记阶段，从根对象出发，查找并标记堆中所有存活的对象。
- 清除阶段，遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表中。

从根节点有可达路径的节点都是存活节点，其余不可达节点都是垃圾节点。
标记阶段结束后会进入清除阶段，依次遍历堆中所有对象，释放内存，并将空闲内存空间用链表链在一块。

### 三色抽象

为了解决标记清除算法造成的长时间 STW，采用三色标记法，来缩短 STW 时间。
三色：黑、白、灰

- 白色对象，潜在的垃圾，其内存可能会被垃圾收集收集。
- 黑色对象，活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象。
- 灰色对象，活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。

三色标记垃圾收集器工作步骤：

1. 从灰色对象的集合中选择一个灰色对象并标记为黑色
2. 将黑色对象指向的所有对象都标记为灰色
3. 重复上述两个步骤，直到不存在灰色对象，则黑色为活跃，白色为可回收节点。

因为用户程序可能在标记过程中修改对象引用的指针，所以三色标记清除算法本身是不可以并发或者增量执行的。
仍需要 STW。

### 屏障技术

内存屏障技术是一种屏障指令。
垃圾收集中的屏障技术更像是一个钩子方法，它在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码。
屏障可以分为读屏障和写屏障。
读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都采用写屏障。

#### 插入写屏障

```go
writePointer(slot, ptr):
  shade(ptr)
  *slot = ptr
```

每当我们执行类似`*slot = ptr`这样的表达式的时候，会执行上述写屏障，通过 shade 函数修改 ptr 指针的颜色。

![Dijkstra插入写屏障](https://img.draveness.me/2020-03-16-15843705141840-dijkstra-insert-write-barrier.png)

上图过程：

1. 垃圾收集器将根对象指向 A 并标记为黑色，将 A 指向的 B 对象标记为灰色
2. 用户修改 A 对象的指向，由指向 B 修改为指向 C，此时调用 shade 函数，会将 C 修改为灰色
3. 垃圾收集器遍历栈，将灰色对象全部改为黑色。

实际上不再存活的 B 对象没有被回收，而是需要在下一轮 GC 才会被回收，所以这是一种相对保守的屏障技术。

#### 删除写屏障

```go
writePointer(slot, ptr)
  shade(*slot)
  *slot = ptr
```

上述代码会在老对象的引用被删除的时候，将白色的老对象涂成灰色。

![Yuasa删除写屏障](https://img.draveness.me/2020-03-16-15843705141846-yuasa-delete-write-barrier.png)

1. 垃圾收集器将根对象指向 A，标记黑色，将 B 标记灰色。
2. 用户程序将 A 指向 B 修改为指向 C，此时触发删除写屏障，将白色的老对象涂灰，因为 B(老对象)已经是灰色，所以不做修改。
3. 用户将 B 指向 C 的指针删除，触发删除写屏障，此时 C 作为 B 的老对象，需要被涂灰。
4. 垃圾收集器依次遍历对象，将它们涂黑。

### 增量和并发

传统的垃圾回收都会暂停用户程序，很多实时性应用无法接受长时间的 STW。

解决方案：

- 增量垃圾收集 增量的标记和清除垃圾，降低应用程序暂停的最长时间。
- 并发垃圾收集 利用多核的计算资源， 在用户程序执行时并发标记和清除垃圾。

#### 增量收集器

增量式的垃圾收集是减少程序最长暂停时间的一种方案，需要结合三色标记法一起使用，而且需要写屏障。

#### 并发收集器

减少整个垃圾收集阶段的时间以及程序的最大暂停时间，通过开启读写屏障，利用多核优势与用户程序并发执行。

## 7.2.3 实现原理

Go 语言的垃圾收集器工作阶段可以分为：清除终止，标记，标记终止和清除

### 全局变量

在垃圾收集过程中会用到一些比较重要的全局变量。

- `runtime.gcphase`表示垃圾收集器当前处于的阶段。
- `runtime.gcBlackenEnabled`是一个布尔值，当垃圾收集器处于标记阶段时，该变量被置为真。
- `runtime.gcController`实现了垃圾收集的调步算法。
- `runtime.gcpercent`触发垃圾收集的内存增长百分比。
- `runtime.writeBarrier`是一个包含写屏障状态的结构体，其中的 enabled 字段表示写屏障的开启与关闭。
- `runtime.worldsema`是全局的信号量，获取该信号量的线程有权利暂停当前应用程序。

### 垃圾收集启动

垃圾收集在启动过程一定会调用 runtime.gcStart 函数，主要职责是修改全局的垃圾收集状态\_GCmark 并做一些准备工作：

1. 两次调用 runtime.gcTrigger.test 方法检查是否满足垃圾收集条件；
2. 暂停程序，在后台启动用于处理标记任务的工作 goroutine、确定所有的内存管理单元都被清理以及其他标记阶段开始前的工作。
3. 进入标记阶段，准备后台的标记工作，根对象的标记工作、以及微对象、恢复用户程序，进入并发扫描和标记阶段。

验证垃圾收集条件的同时，还会在循环中不断调用 sweepone 清理已经被标记的内存单元，完成上一轮垃圾回收的收尾工作。

#### 暂停与恢复程序

runtime.stopTheWorldWithSema 和 runtime.startTheWorldWithSema 是一对用于暂停和恢复程序的核心函数。
暂停程序主要使用了 runtime.preemptall 函数，该函数会循环调用 preemptone 函数。

#### 后台标记模式

在垃圾收集启动期间，运行时会调用 runtime.gcBgMarkStartWorkers 为全局每一个处理器创建用于执行后台标记任务的 Goroutine。
每一个 Goroutine 都会运行 runtime.gcBgMarkWorker，启动后陷入睡眠等待调度器唤醒。

### 并发扫描与标记辅助

runtime.gcBgMarkWorker 是后台标记任务执行的函数，该函数的循环中执行了对内存中对象图的扫描和标记。
实现原理：

1. 获取当前处理器以及 Goroutine 打包成 parkInfo 类型的结构体并主动陷入休眠等待唤醒。
2. 根据处理器上的 gcMarkWorkerMode 模式决定扫描任务的策略。
3. 所有标记任务都完成后，调用 runtime.gcMarkDone 方法完成标记。

#### 工作池

runtime.gcWork 结构体是垃圾收集器中工作池的抽象。

为了减少锁竞争，运行时会在每个处理器上保留独立的待扫描工作，然而这会遇到与调度器一样的问题，不同处理器的资源不同，导致部分处理器没有工作可以做，垃圾收集器采用了同调度器差不多的工作窃取机制来解决这一问题。

runtime.gcWork.balance 方法会将处理器本地一部分工作放回全局队列。
runtime.gcWork 为垃圾收集器提供了生产和消费任务的抽象，该结构体持有两个重要的工作缓冲区 wbuf1 和 wbuf2，这两个缓冲区一个是主缓冲区，一个是储备缓冲区。

#### 扫描对象

runtime.gcDrain 函数扫描工作缓冲区中的灰色对象，根据传入的 gcDrainFlags 的不同选择不同的策略。

#### 写屏障

写屏障是保证 Go 语言并发标记安全不可获取的技术，我们需要混合写屏障维护对象图的弱三色不变性，然而写屏障的实现需要编译器和运行时的共同协作。在 SSA 中间代码生成阶段，编译器会使用 cmd/compile/internal/ssa.writebarrier 函数在 Store， Move 和 Zero 操作中加入写屏障。

#### 辅助标记

### 内存清理

垃圾收集的清理中包含对象回收器 recliamer 和内存单元回收器，这两种回收器使用不同的算法清理堆内存：

- 对象回收器在内存管理单元中查找并释放未被标记的对象，但是如果 runtime.mspan 中的所有对象都没有被标记，整个单元就会被直接回收，该过程会被 runtime.mcentral.cacheSpan 或者 runtime.sweepone 异步触发。
- 内存单元回收器会在内存中查找所有的对象都未被标记的 mspan，该过程会被 runtime.mheap.reclaim 触发。

runtime.sweepone 会在堆内存中查找待清理的内存管理单元。

#### 混合写屏障

混合写屏障将被覆盖的对象标记成灰色并在当前栈没有被扫描时将新对象也标记成灰色。

```go
writePointer(slot, ptr):
  shade(*slot)
  if current stack is grey:
    shade(ptr)
  *slot = ptr
```

为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误回收。
