# Go 语言内存管理

## 逃逸分析

Go 语言较之 C 语言一个很大的优势就是自带 GC 功能，写 C 语言时，在一个函数内声明的变量在函数退出后悔自动释放，因为这些变量分配在栈上。
如果你想变量的数据能在函数退出后还能访问，就需要调用 malloc 方法在堆上申请内存。
Go 语言不需要主动调用 malloc 来分配内存，编译器会自动分析，哪些变量需要使用堆内存，编译器的分析过程被称为逃逸分析。
但是逃逸分析并不是完全准确的，是存在缺陷的。有些变量其实分配在栈上是没有问题的，但编译后程序还是将它们放在了堆内存上。
学习了解逃逸分析，可以有意识的避开这些坑。

### 逃逸分析的缺陷

**多级间接赋值容易导致逃逸**

这里的多级简介指的是，对某个引用类对象中的引用类成员进行赋值。Go 语言中的引用类数据类型有 func, interface, slice, map, chan, \*Type(指针)
记住公式：
`Object.Field = value`, 如果 Object 和 Field 都是引用类型，则会导致数据 value 逃逸。这里的等号包括赋值和传参。

## Go 垃圾回收

编写 Go 语言不需要像 C 语言一样手动去 malloc，因为逃逸分析帮我们做了操作，为 Go 语言的 GC 则帮我们执行了 free 操作。
GC 机制很不错，降低了编程门槛，但这是以损耗性能为代价换来的。

- 1.1 版本 标记+清除方式，整个过程需要 STW stop the world
- 1.3 版本 标记过程 STW，清除过程并行
- 1.5 版本 标记过程使用三色标记法
- 1.8 版本 Hibird Write Barrier
- 未来

### 标记清除

垃圾回收的算法很多，比如常见的引用计数，节点复制等。
Go 采用的标记清除方式。

从 Root 节点开始一层层扫描，将所有能够触达的 object 标记，那么堆空间中剩余的未被标记点 object 就是垃圾了。最后再遍历一遍堆空间，将未标记的 object 清除。

最开始 Go 的整个 GC 过程中需要 STW，因为用户进程如果在 GC 过程中修改了变量的引用关系，可能会导致清理错误。
但是 STW 机制经常会造成整个系统卡住，造成几百毫秒的延迟。

### 并行清除

只对标记过程 STW，清除过程不需要 STW，之后的优化都是针对 STW 的，尽可能的缩短 STW 占用的时间。

### 三色标记法

为了能让标记过程也并行进行，Go 采用了三色标记 + 写屏障的机制。

1. GC 开始时，认为所有的 object 都是白色的，即所有的 object 都是垃圾。
1. 从 root 区域开始遍历，将触及的区域都标记为灰色。
1. 遍历所有的灰色 object，将它们内部的引用标记为灰色，将自身标记为黑色。
1. 循环第三步，直到将所有的灰色 object 都标记为黑色，就只剩下白色和黑色，白色的都是垃圾。
1. 对于黑色 object，如果在标记期间发生了写操作，写屏障会在真正赋值前将新对象标记为灰色。
1. 标记过程中，mallocgc 新分配的 object 会先被标记成黑色再返回。

### Hibird Write Barrier

混合写屏障，其会在赋值前，对旧数据置灰色，再视情况对新数据置灰色。
混合写屏障会有一点代价

```go
B.next = C
B.next = nil
```

当 B.next = nil 时，C 确确实实变成了垃圾，但是 C 却被标记为灰色，所以被保留了下来，需要在下一轮 GC 才会被回收。

### 何时会触发 GC

一般是当堆上的内存达到一定数值后触发。可以通过设置环境变量 GOGC 或者`debug.SetGCPercent()`设置，默认是 100%，也就是，如果当前堆使用了 10MB，当它占用存储增长到 20MB 时就会触发 GC。
再就是每隔两分钟，期间没有发生 GC，则也会触发一次 GC。
也可以通过手动调用`runtime.GC()`来触发。

### 其他优化

扫描过程最多使用 25%的 CPU

### 总结

GC 虽然较早期的版本有了较大的提升，但是依旧很影响性能，作为用户能做的就是尽可能的避开 GC。
比如尽量少的使用多级引用的数据结构，引用层级越多，GC 的成本也就越高。
