Go中调度顺序优先级
- 本地运行队列
- 全局运行队列+锁
- 网络轮询器

非阻塞系统调用，将goroutine阻塞在运行时轮询上，释放当前线程用于处理其他G
例如HTTP调用，使用系统调用获取资源，由于资源尚未准备就绪，Go会使用网络轮询将G暂停，在等到资源准备就绪后通知G资源就绪。这种情况下处理这个阻塞G的线程不会被阻塞，而是去处理别的G

- 工作偷窃 （本地工作队列为空时从其他队列中窃取Goroutine）

当一个线程有太多工作而另一个线程空闲时，可以通过工作偷窃解决问题。

系统阻塞线程时，会唤起另一个线程继续处理可运行的G，这说明系统调用中可以有多个内核线程，可能会比CPU核数多，将会产生以下开销：
- 偷窃工作时，扫描所有运行时内核线程的本地运行队列，大多数线程都是空闲的，队列是空的
- 垃圾回收时也一样要扫描所有内核线程。

**引入逻辑处理器P**

视为在线程上运行的本地调度程序。
P的数量默认为当前进程可以使用的逻辑CPU数量。

本地运行队列放入 逻辑处理器 P中，而不是线程中。

每个 G 将在分配了逻辑 P 的 线程 M 上运行。

这样一来 偷窃工作和垃圾回收 只需要在逻辑处理器P的本地运行队列进行。

> 阻塞系统调用返回
- 运行时尝试获取之前绑定的P，获取成功则继续执行
- 运行时尝试从空闲P队列获取一个P，获取成功则继续执行
- 运行时无法继续在绑定的M上执行G，则将G全部放入全局队列中，并且将绑定的M返回给M空闲队列。

空闲M与抢占式调度的权衡，空闲线程 优于 线程之间的频繁抢占以及频繁的创建和销毁。
线程空闲后 使其执行自选操作以备将来使用。

**Goroutine的四个典型的公平约束**

任何运行时间超过10ms的G都被标记为可抢占，抢占仅在函数执行开始出才能完成，Go当前在函数开始处中使用了由编译器插入的协作抢占点。

无限循环 如果不包含任何抢占点（例如函数调用或分配内存），则会阻止其他goroutine的运行。

> [参考资料](https://tonybai.com/2020/03/21/illustrated-tales-of-go-runtime-scheduler/)